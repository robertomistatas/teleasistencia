{"version":3,"file":"utils-d3c5c3a6.js","sources":["../../src/utils/textUtils.js","../../src/utils/dateUtils.js","../../src/utils/statsUtils.js"],"sourcesContent":["// Función para normalizar nombres (remover espacios extra, normalizar mayúsculas/minúsculas)\r\nexport const normalizeName = (name) => {\r\n    if (!name) return '';\r\n    return name.toString()\r\n        .trim()\r\n        .toLowerCase()\r\n        .normalize(\"NFD\") // Normalizar caracteres acentuados\r\n        .replace(/[\\u0300-\\u036f]/g, \"\") // Remover diacríticos\r\n        .replace(/\\s+/g, ' '); // Remover espacios múltiples\r\n};\r\n","// Convertir fecha de Excel a ISO string\r\nexport const excelDateToISO = (fecha, hora = null) => {\r\n    if (!fecha) return null;\r\n    try {\r\n        // Si es número (formato Excel)\r\n        if (typeof fecha === 'number') {\r\n            const excelDate = new Date((fecha - 25569) * 86400 * 1000);\r\n            return excelDate.toISOString();\r\n        }\r\n\r\n        // Si ya es ISO string\r\n        if (typeof fecha === 'string' && fecha.includes('T')) {\r\n            return fecha;\r\n        }\r\n\r\n        // Si es string con formato dd/mm/yyyy o dd-mm-yyyy\r\n        let fechaParts;\r\n        if (fecha.includes('/')) {\r\n            fechaParts = fecha.split('/');\r\n        } else if (fecha.includes('-')) {\r\n            fechaParts = fecha.split('-');\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n        let [day, month, year] = fechaParts.map(n => parseInt(n, 10));\r\n        \r\n        // Ajustar año si es de dos dígitos\r\n        if (year < 100) {\r\n            year = year + 2000;\r\n        }\r\n\r\n        // Validar componentes de la fecha\r\n        if (!day || !month || !year || month > 12 || day > 31) return null;\r\n\r\n        // Construir fecha con hora si está disponible\r\n        let dateStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;\r\n        if (hora) {\r\n            dateStr += `T${hora.toString().padStart(8, '0')}`;\r\n        } else {\r\n            dateStr += 'T00:00:00.000Z';\r\n        }\r\n\r\n        const date = new Date(dateStr);\r\n        return !isNaN(date.getTime()) ? date.toISOString() : null;\r\n    } catch (error) {\r\n        console.error('Error parsing date:', fecha, error);\r\n        return null;\r\n    }\r\n};\r\n\r\n// Serializar una llamada para almacenamiento/contexto\r\nexport const serializeLlamada = (llamada) => {\r\n    if (!llamada || typeof llamada !== 'object') return null;\r\n    return {\r\n        fecha: llamada.fecha ? excelDateToISO(llamada.fecha) : null,\r\n        hora: llamada.hora || null,\r\n        duracion: llamada.duracion || 0,\r\n        tipo: llamada.tipo || '',\r\n        telefono: llamada.telefono || '',\r\n        teleoperadora: llamada.teleoperadora || '',\r\n        comentarios: llamada.comentarios || ''\r\n    };\r\n};\r\n\r\n// Serializar un array de llamadas\r\nexport const serializeLlamadas = (llamadas) => {\r\n    if (!Array.isArray(llamadas)) return [];\r\n    return llamadas.filter(Boolean).map(serializeLlamada).filter(Boolean);\r\n};\r\n\r\n// Convertir estructuras de datos para serialización\r\nexport const prepareStatsForStorage = (stats) => {\r\n    if (!stats) return null;\r\n\r\n    try {\r\n        return {\r\n            totalLlamadas: stats.totalLlamadas || 0,\r\n            entrantes: stats.entrantes || 0,\r\n            salientes: stats.salientes || 0,\r\n            duracionTotal: stats.duracionTotal || 0,\r\n            duracionPromedio: stats.duracionPromedio || 0,\r\n            beneficiarios: Array.from(stats.beneficiarios || []),\r\n            beneficiariosAlDia: Array.from(stats.beneficiariosAlDia || []),\r\n            beneficiariosPendientes: Array.from(stats.beneficiariosPendientes || []),\r\n            beneficiariosUrgentes: Array.from(stats.beneficiariosUrgentes || []),\r\n            comunas: Object.fromEntries(stats.comunas || new Map()),\r\n            teleoperadoras: stats.teleoperadoras || {},\r\n            llamadasPorBeneficiario: Object.fromEntries(\r\n                Object.entries(stats.llamadasPorBeneficiario || {}).map(([key, datos]) => [\r\n                    key,\r\n                    Array.isArray(datos) ? serializeLlamadas(datos) : datos\r\n                ])\r\n            ),\r\n            ultimasLlamadas: Object.fromEntries(\r\n                Object.entries(stats.ultimasLlamadas || {}).map(([key, llamada]) => [\r\n                    key,\r\n                    serializeLlamada(llamada)\r\n                ]).filter(([_, llamada]) => llamada !== null)\r\n            ),\r\n            llamadasExitosas: Object.fromEntries(\r\n                Object.entries(stats.llamadasExitosas || {}).map(([key, llamadas]) => [\r\n                    key,\r\n                    serializeLlamadas(llamadas)\r\n                ])\r\n            )\r\n        };\r\n    } catch (error) {\r\n        console.error('Error preparing stats for storage:', error);\r\n        return null;\r\n    }\r\n};\r\n","// Constantes\r\nexport const ESTADOS = {\r\n    AL_DIA: 'al-dia',\r\n    PENDIENTE: 'pendiente',\r\n    URGENTE: 'urgente'\r\n};\r\n\r\n// Validar si una llamada fue exitosa\r\nexport const isLlamadaExitosa = (comentarios) => {\r\n    if (!comentarios || typeof comentarios !== 'string') return false;\r\n    const comentariosLower = comentarios.toLowerCase().trim();\r\n    return [\r\n        'exitoso',\r\n        'exitosa',\r\n        'contesta',\r\n        'contactado',\r\n        'contactada',\r\n        'se logra contactar',\r\n        'responde'\r\n    ].some(term => comentariosLower.includes(term));\r\n};\r\n\r\n// Validar y convertir una llamada individual\r\nexport const validateLlamada = (llamada) => {\r\n    if (!llamada || typeof llamada !== 'object') return null;\r\n    return {\r\n        fecha: llamada.fecha || null,\r\n        hora: llamada.hora || null,\r\n        duracion: typeof llamada.duracion === 'number' ? llamada.duracion : 0,\r\n        tipo: llamada.tipo || '',\r\n        telefono: llamada.telefono || '',\r\n        teleoperadora: llamada.teleoperadora || '',\r\n        comentarios: llamada.comentarios || ''\r\n    };\r\n};\r\n\r\n// Validar y convertir un array de llamadas\r\nexport const validateLlamadas = (llamadas) => {\r\n    if (!Array.isArray(llamadas)) return [];\r\n    return llamadas.map(validateLlamada).filter(Boolean);\r\n};\r\n\r\n// Crear estado inicial para las métricas\r\nexport const createInitialStats = () => ({\r\n    totalLlamadas: 0,\r\n    entrantes: 0,\r\n    salientes: 0,\r\n    duracionTotal: 0,\r\n    duracionPromedio: 0,\r\n    beneficiarios: new Set(),\r\n    llamadasPorBeneficiario: {},\r\n    ultimasLlamadas: {},\r\n    llamadasExitosas: {},\r\n    beneficiariosAlDia: new Set(),\r\n    beneficiariosPendientes: new Set(),\r\n    beneficiariosUrgentes: new Set(),\r\n    comunas: new Map(),\r\n    teleoperadoras: {}\r\n});\r\n\r\n// Convertir datos almacenados a estado válido\r\nexport const parseStoredStats = (storedStats) => {\r\n    if (!storedStats || typeof storedStats !== 'object') return createInitialStats();\r\n\r\n    const stats = createInitialStats();\r\n\r\n    try {\r\n        // Métricas numéricas básicas\r\n        stats.totalLlamadas = storedStats.totalLlamadas || 0;\r\n        stats.entrantes = storedStats.entrantes || 0;\r\n        stats.salientes = storedStats.salientes || 0;\r\n        stats.duracionTotal = storedStats.duracionTotal || 0;\r\n        stats.duracionPromedio = storedStats.duracionPromedio || 0;\r\n\r\n        // Conjuntos\r\n        stats.beneficiarios = new Set(storedStats.beneficiarios || []);\r\n        stats.beneficiariosAlDia = new Set(storedStats.beneficiariosAlDia || []);\r\n        stats.beneficiariosPendientes = new Set(storedStats.beneficiariosPendientes || []);\r\n        stats.beneficiariosUrgentes = new Set(storedStats.beneficiariosUrgentes || []);\r\n\r\n        // Comunas\r\n        stats.comunas = new Map(Object.entries(storedStats.comunas || {}));\r\n\r\n        // Llamadas por beneficiario\r\n        if (storedStats.llamadasPorBeneficiario) {\r\n            Object.entries(storedStats.llamadasPorBeneficiario).forEach(([beneficiario, datos]) => {\r\n                if (datos && Array.isArray(datos.llamadas)) {\r\n                    stats.llamadasPorBeneficiario[beneficiario] = validateLlamadas(datos.llamadas);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Últimas llamadas\r\n        if (storedStats.ultimasLlamadas) {\r\n            Object.entries(storedStats.ultimasLlamadas).forEach(([beneficiario, llamada]) => {\r\n                const validatedLlamada = validateLlamada(llamada);\r\n                if (validatedLlamada) {\r\n                    stats.ultimasLlamadas[beneficiario] = validatedLlamada;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Llamadas exitosas\r\n        if (storedStats.llamadasExitosas) {\r\n            Object.entries(storedStats.llamadasExitosas).forEach(([beneficiario, llamadas]) => {\r\n                stats.llamadasExitosas[beneficiario] = validateLlamadas(llamadas);\r\n            });\r\n        }\r\n\r\n        // Teleoperadoras\r\n        stats.teleoperadoras = storedStats.teleoperadoras || {};\r\n\r\n        return stats;\r\n    } catch (error) {\r\n        console.error('Error parsing stored stats:', error);\r\n        return createInitialStats();\r\n    }\r\n};\r\n"],"names":["normalizeName","name","toString","trim","toLowerCase","normalize","replace","excelDateToISO","fecha","hora","Date","toISOString","includes","fechaParts","split","day","month","year","map","n","parseInt","dateStr","padStart","date","isNaN","getTime","error","console","validateLlamada","llamada","duracion","tipo","telefono","teleoperadora","comentarios","validateLlamadas","llamadas","Array","isArray","filter","Boolean","createInitialStats","totalLlamadas","entrantes","salientes","duracionTotal","duracionPromedio","beneficiarios","Set","llamadasPorBeneficiario","ultimasLlamadas","llamadasExitosas","beneficiariosAlDia","beneficiariosPendientes","beneficiariosUrgentes","comunas","Map","teleoperadoras","parseStoredStats","storedStats","stats","Object","entries","forEach","beneficiario","datos","validatedLlamada"],"mappings":"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"}